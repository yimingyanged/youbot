#include "FabMap.h"
#include <iomanip>
#include <functional>

//**************************************************************************
// Running FabMap as a stand-alone binary:
//
// Example call:
//   > FabMap Config.moos
// where Config.moos is a FabMap configuration file.
//
// As part of the Config.moos file you specify a "scenes file" (.oxs file) which
// contains a sequential list of bag-of-words observations. FabMap will then
// process all the observations in the .oxs file and output the scene-to-scene
// loop closure probability matrix. The input (.oxs file) for all the images in
// a directory can be generated by running the WordMaker binary (see
// ../WordMaker)
//
// NB: The order in which WordMaker processes images (and thus the order in
// which they appear in the .oxs file and get processed by FabMap) corresponds
// to the default sort order of the filesystem. Make sure that this is also the
// order in which your images were collected, because FabMap uses the temporal
// information to reinforce loop closures!
//
//**************************************************************************
//Running FabMap "live" on a robot:
//
// You don't have to run FabMap as a stand-alone binary. You can also construct
// a FabMap object from within your own C++ or Python program, and then supply
// new observations to the FabMap object directly. e.g. You will want to do this
// to use FabMap inside an IPC system such as ROS or MOOS. This is also an easy
// way to interact with FabMap without changing the FabMap code directly. For
// example the API lets you add an external geometric verification test to
// confirm a putative FabMap match. There is no geometric checking in this code
// release, so adding your own check will give a big quality improvement!
//
// See FabMap.h or fabmap.py for an explanation of external API functions.
//**************************************************************************

int main(int argc, char * argv[])
{
    const char * sMissionFile = "Config.moos";
    const char * sMOOSName    = "pFabMapV2";

    switch(argc)
    {
    case 3:
        sMOOSName    = argv[2];
    case 2:
        sMissionFile = argv[1];
    }
   
    // Read in basic parameters needed to construct a LoopCloser object.
    CProcessConfigReader FileReader;
    FileReader.SetFile(sMissionFile);

	if (!FileReader.IsOpen()) {
		cout << "Could not find config file: " << sMissionFile << endl
   			 << "Example call: FabMapV2 Config.moos" << endl
   			 << "Sample config files are available in the FabMapV2/config directory" << endl;
		exit(0);
	}
    
    // Set paths and constants.
    string vocab_path, vocabName;
    double p_observe_given_exists, p_observe_given_not_exists, p_at_new_place, df_likelihood_smoothing_factor;
    FileReader.GetValue("VocabPath", vocab_path);
    FileReader.GetValue("VocabName", vocabName);
    FileReader.GetValue("P_OBSERVE_GIVEN_EXISTS", p_observe_given_exists);
  	FileReader.GetValue("P_OBSERVE_GIVEN_NOT_EXISTS", p_observe_given_not_exists);
    FileReader.GetValue("LIKELIHOOD_SMOOTHING_FACTOR", df_likelihood_smoothing_factor);
    FileReader.GetValue("P_AT_NEW_PLACE", p_at_new_place);

    // Determine the vocabulary size.
    unsigned int vocab_size;
    if(ParseOXV_PeekDimensions(vocab_path + vocabName + ".oxv", vocab_size))
    {
        FabMapCalculator TheLoopCloser(vocab_path,
                                       vocabName,
                                       p_observe_given_exists,
                                       p_observe_given_not_exists,
                                       p_at_new_place,
                                       vocab_size,
                                       df_likelihood_smoothing_factor);

        TheLoopCloser.BatchProcess(sMOOSName,sMissionFile);
    }

    return 0;
}
